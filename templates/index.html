<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>ChargeMyHyundai Price Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
        }
        
        .container {
            display: flex;
            height: 100vh;
            height: 100dvh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 700px;
            background: #16213e;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #0f3460;
            overflow: hidden;
            /* No transition by default - prevents flickering during breakpoint change */
            transition: none;
        }
        
        /* Enable transitions only when sidebar is being actively toggled */
        .sidebar.transitioning {
            transition: width 0.3s ease, min-width 0.3s ease;
        }
        
        /* Disable transitions during responsive breakpoint changes */
        .sidebar.no-transition {
            transition: none !important;
        }
        
        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            border-right: none;
            overflow: hidden;
        }
        
        .sidebar.collapsed .sidebar-header,
        .sidebar.collapsed .sidebar-content {
            opacity: 0;
            visibility: hidden;
        }
        
        /* Sidebar Toggle Button (Desktop) */
        .sidebar-toggle {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1003;
            width: 28px;
            height: 60px;
            background: linear-gradient(135deg, #002f6c 0%, #00447c 100%);
            border: none;
            border-radius: 0 8px 8px 0;
            color: #00a9e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            transition: left 0.3s ease, background 0.2s ease;
        }
        
        .sidebar-toggle:hover {
            background: linear-gradient(135deg, #003d8c 0%, #0055a0 100%);
        }
        
        .sidebar-toggle i {
            transition: transform 0.3s ease;
        }
        
        .sidebar-toggle.sidebar-open {
            left: 700px;
        }
        
        .sidebar-toggle.sidebar-open i {
            transform: rotate(180deg);
        }
        
        .sidebar-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 20px;
            background: linear-gradient(135deg, #002f6c 0%, #00447c 100%);
            border-bottom: 2px solid #00a9e0;
        }
        
        .sidebar-header h1 {
            font-size: 1.4em;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sidebar-header h1 i {
            color: #00a9e0;
        }
        
        .sidebar-header p {
            font-size: 0.85em;
            color: #aaa;
            margin-top: 5px;
        }
        
        /* Filters Panel */
        .filters-panel {
            width: 50%;
            padding: 12px;
            background: #1a1a2e;
            border-right: 1px solid #0f3460;
            overflow-y: auto;
        }
        
        .filter-group {
            margin-bottom: 15px;
        }
        
        .filter-group label {
            display: block;
            font-size: 0.85em;
            color: #aaa;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        /* Tariff Toggle */
        .tariff-toggle {
            display: flex;
            background: #0f3460;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tariff-btn {
            flex: 1;
            padding: 12px 15px;
            border: none;
            background: transparent;
            color: #888;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }
        
        .tariff-btn:hover {
            color: #fff;
        }
        
        .tariff-btn.active {
            background: #00a9e0;
            color: #fff;
        }
        
        .tariff-btn .price {
            display: block;
            font-size: 0.75em;
            opacity: 0.8;
            margin-top: 3px;
        }
        
        /* Power Type Toggle */
        .power-toggle {
            display: flex;
            gap: 10px;
        }
        
        .power-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #0f3460;
            background: transparent;
            color: #888;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .power-btn:hover {
            border-color: #00a9e0;
            color: #fff;
        }
        
        .power-btn.active {
            border-color: #00a9e0;
            background: rgba(0, 169, 224, 0.2);
            color: #00a9e0;
        }
        
        /* Max Price Slider */
        .price-slider {
            width: 100%;
        }
        
        .price-slider input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .price-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00a9e0;
            cursor: pointer;
        }
        
        .price-value {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
        }
        
        .price-value .current {
            color: #00a9e0;
            font-weight: bold;
        }
        
        /* Additional Filters */
        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .filter-chip {
            padding: 6px 12px;
            border: 1px solid #0f3460;
            border-radius: 20px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
            background: transparent;
            color: #888;
        }
        
        .filter-chip:hover {
            border-color: #00a9e0;
            color: #fff;
        }
        
        .filter-chip.active {
            background: #00a9e0;
            border-color: #00a9e0;
            color: #fff;
        }
        
        /* Stations List */
        .stations-list {
            width: 50%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0;
        }
        
        .list-header-fixed {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #0f3460;
            border-bottom: 1px solid #1a3a5c;
            flex-shrink: 0;
        }
        
        .list-header-fixed span {
            font-size: 0.9em;
            color: #8ab4d8;
            font-weight: 500;
        }
        
        .list-scroll-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        .station-card {
            background: linear-gradient(145deg, #0f3460 0%, #16213e 100%);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.25s ease;
            border: 1px solid #1a3a5c;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .station-card:hover {
            border-color: #00a9e0;
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 169, 224, 0.15);
        }
        
        .station-card.selected {
            border-color: #00a9e0;
            background: linear-gradient(145deg, #0a2d4d 0%, #0f3460 100%);
            box-shadow: 0 0 0 2px rgba(0, 169, 224, 0.2);
        }
        
        .station-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .station-info {
            flex: 1;
            min-width: 0;
        }
        
        .station-name {
            font-weight: 600;
            font-size: 0.95em;
            color: #fff;
            line-height: 1.3;
            margin-bottom: 4px;
            word-wrap: break-word;
        }
        
        .station-price {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            white-space: nowrap;
            flex-shrink: 0;
            box-shadow: 0 2px 6px rgba(46, 204, 113, 0.3);
        }
        
        .station-price.cheap {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 2px 6px rgba(46, 204, 113, 0.3);
        }
        
        .station-price.expensive {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 2px 6px rgba(231, 76, 60, 0.3);
        }
        
        .station-price.moderate {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 2px 6px rgba(243, 156, 18, 0.3);
        }
        
        .station-price.foreign {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 2px 6px rgba(155, 89, 182, 0.3);
        }
        
        .station-address {
            font-size: 0.82em;
            color: #8ab4d8;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 6px;
            line-height: 1.4;
        }
        
        .station-address i {
            color: #00a9e0;
            flex-shrink: 0;
            margin-top: 2px;
        }
        
        .station-details {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.8em;
            color: #7a99b5;
            padding-top: 10px;
            border-top: 1px solid #1a3a5c;
        }
        
        .station-details span {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .status-available {
            color: #2ecc71;
        }
        
        .status-occupied {
            color: #e74c3c;
        }
        
        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .loading i {
            font-size: 2em;
            margin-bottom: 10px;
            color: #00a9e0;
        }
        
        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        /* Custom Markers */
        .price-marker {
            background: linear-gradient(135deg, #00a9e0, #0077b6);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 11px;
            white-space: nowrap;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid white;
            text-align: center;
            min-width: 45px;
        }
        
        .price-marker.dual {
            padding: 4px 6px;
            font-size: 10px;
            line-height: 1.3;
            min-width: 60px;
        }
        
        .price-marker.expensive {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        .price-marker.moderate {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        
        .price-marker.cheap {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }
        
        .price-marker.unavailable {
            background: #666;
            opacity: 0.7;
        }
        
        .cluster-marker {
            background: #0f3460;
            color: white;
            padding: 6px 10px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 11px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid #00a9e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            text-align: center;
            line-height: 1.2;
        }
        
        .cluster-marker.cheap {
            background: linear-gradient(135deg, #1a5d2a, #0f3460);
            border-color: #4caf50;
        }
        
        .cluster-marker.moderate {
            background: linear-gradient(135deg, #8b6914, #0f3460);
            border-color: #f1c40f;
        }
        
        .cluster-marker.expensive {
            background: linear-gradient(135deg, #8b2020, #0f3460);
            border-color: #e74c3c;
        }
        
        .cluster-count {
            font-size: 13px;
            font-weight: bold;
        }
        
        .cluster-price {
            font-size: 10px;
            opacity: 0.9;
        }
        
        /* Map Legend */
        .map-legend {
            position: absolute;
            bottom: 20px;
            right: 10px;
            background: rgba(22, 33, 62, 0.95);
            padding: 10px 12px;
            border-radius: 10px;
            z-index: 1000;
            font-size: 0.8em;
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 6px;
            color: #fff;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 3px;
            color: #aaa;
        }
        
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 6px;
        }
        
        .legend-color.cheap { background: linear-gradient(135deg, #2ecc71, #27ae60); }
        .legend-color.moderate { background: linear-gradient(135deg, #f39c12, #e67e22); }
        .legend-color.expensive { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .legend-color.foreign { background: linear-gradient(135deg, #9b59b6, #8e44ad); }
        
        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 33, 62, 0.95);
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 1001;
            display: none;
            align-items: center;
            gap: 10px;
            font-size: 0.85em;
        }
        
        .loading-overlay.visible {
            display: flex;
        }
        
        .loading-overlay i {
            color: #00a9e0;
        }
        
        .loading-progress {
            color: #aaa;
        }
        
        /* Operator Filter */
        .operator-filter {
            background: #0f3460;
            border-radius: 8px;
            padding: 10px;
        }
        
        .operator-filter-header {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .operator-filter-btn {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #1a1a2e;
            background: transparent;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
        }
        
        .operator-filter-btn:hover {
            border-color: #00a9e0;
            color: #fff;
        }
        
        .operator-filter-btn.active-include {
            background: #2ecc71;
            border-color: #2ecc71;
            color: #fff;
        }
        
        .operator-filter-btn.active-exclude {
            background: #e74c3c;
            border-color: #e74c3c;
            color: #fff;
        }
        
        .operator-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 280px;
            overflow: hidden;
        }
        
        .operator-tags.expanded {
            max-height: none;
            overflow-y: auto;
            max-height: 50vh;
        }
        
        .operator-expand-container {
            margin-top: 6px;
        }
        
        .operator-tag {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s;
            background: #1a1a2e;
            color: #888;
            border: 1px solid transparent;
        }
        
        .operator-tag:hover {
            border-color: #00a9e0;
            color: #fff;
        }
        
        .operator-tag.included {
            background: rgba(46, 204, 113, 0.3);
            border-color: #2ecc71;
            color: #2ecc71;
        }
        
        .operator-tag.excluded {
            background: rgba(231, 76, 60, 0.3);
            border-color: #e74c3c;
            color: #e74c3c;
        }
        
        .operator-tag.placeholder {
            color: #666;
            cursor: default;
        }
        
        .operator-tag.expand-more {
            color: #00a9e0;
            cursor: pointer;
            border-color: #00a9e0;
        }
        
        .operator-tag.expand-more:hover {
            background: rgba(0, 169, 224, 0.2);
        }
        
        /* Station CPO Name */
        .station-cpo {
            font-size: 0.78em;
            color: #5aa3d8;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .station-cpo::before {
            content: '⚡';
            font-size: 0.9em;
        }
        
        /* Foreign currency marker */
        .price-marker.foreign {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
        }
        
        .sort-select {
            background: #1a1a2e;
            color: #fff;
            border: 1px solid #0f3460;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.8em;
            cursor: pointer;
        }
        
        /* Stats Bar */
        .stats-bar {
            position: absolute;
            bottom: 20px;
            left: 10px;
            top: auto;
            right: auto;
            transform: none;
            background: rgba(22, 33, 62, 0.95);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.85em;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .stat i {
            color: #00a9e0;
        }
        
        .stat-value {
            font-weight: bold;
            color: #fff;
        }
        
        .stat-label {
            color: #8ab4d8;
            font-size: 0.85em;
        }
        
        /* Popup */
        .leaflet-popup-content-wrapper {
            background: #16213e;
            color: #fff;
            border-radius: 10px;
        }
        
        .leaflet-popup-tip {
            background: #16213e;
        }
        
        .popup-content {
            padding: 5px;
            min-width: 220px;
        }
        
        .popup-title {
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 8px;
            color: #00a9e0;
        }
        
        .popup-address {
            font-size: 0.85em;
            color: #aaa;
            margin-bottom: 10px;
        }
        
        .popup-prices {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .popup-price-column {
            flex: 1;
            background: #0f3460;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        
        .popup-price-column.ac {
            border-top: 3px solid #3498db;
        }
        
        .popup-price-column.dc {
            border-top: 3px solid #e67e22;
        }
        
        .popup-price-type {
            font-weight: bold;
            font-size: 0.85em;
            color: #fff;
            margin-bottom: 6px;
        }
        
        .popup-price-main {
            font-size: 1.1em;
            font-weight: bold;
            color: #00a9e0;
            margin-bottom: 4px;
        }
        
        .popup-price-fee {
            font-size: 0.75em;
            color: #888;
        }
        
        .popup-price-avail {
            font-size: 0.75em;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .popup-price-avail i {
            margin-right: 4px;
        }
        
        .popup-price-blocking {
            font-size: 0.7em;
            color: #e74c3c;
            margin-top: 4px;
            padding: 3px 6px;
            background: rgba(231, 76, 60, 0.15);
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .popup-price-blocking i {
            color: #e74c3c;
        }
        
        .popup-refresh-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: linear-gradient(135deg, #0f3460, #16213e);
            border: 1px solid #1a3a5c;
            border-radius: 8px;
            color: #8ab4d8;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .popup-refresh-btn:hover {
            background: linear-gradient(135deg, #16213e, #1a3a5c);
            border-color: #00a9e0;
            color: #00a9e0;
        }
        
        .popup-refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .popup-refresh-btn.loading i {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .popup-cache-info {
            font-size: 0.7em;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }
        
        .popup-cache-info.stale {
            color: #e67e22;
        }
        
        .station-blocking-fee {
            color: #e74c3c;
            font-size: 0.75em;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 4px;
        }
        
        .popup-price-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .popup-price-row:last-child {
            margin-bottom: 0;
        }
        
        .popup-price-label {
            color: #888;
        }
        
        .popup-price-value {
            font-weight: bold;
            color: #00a9e0;
        }
        
        .popup-operator {
            font-size: 0.8em;
            color: #888;
        }
        
        .popup-details {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.8em;
            color: #7a99b5;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #1a3a5c;
        }
        
        .popup-details span {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .popup-details i {
            color: #00a9e0;
        }
        
        /* Search Box */
        .search-box {
            position: absolute;
            top: 10px;
            left: 50px;
            z-index: 1000;
            background: rgba(22, 33, 62, 0.95);
            border-radius: 25px;
            padding: 5px;
            display: flex;
            align-items: center;
            width: 300px;
        }
        
        .search-box input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 10px 15px;
            color: #fff;
            font-size: 0.9em;
            outline: none;
        }
        
        .search-box input::placeholder {
            color: #666;
        }
        
        .search-box button {
            background: #00a9e0;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .search-box button:hover {
            background: #0077b6;
        }
        
        /* Mobile Filter Button (top right, next to search) */
        .mobile-filter-btn {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            width: 46px;
            height: 46px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            font-size: 1.1em;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(46, 204, 113, 0.4);
            transition: all 0.3s ease;
        }
        
        .mobile-filter-btn:hover,
        .mobile-filter-btn:focus {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.5);
        }
        
        .mobile-filter-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 2px 10px rgba(231, 76, 60, 0.4);
        }
        
        /* Visually hidden class for accessibility */
        @media (max-width: 1200px) and (min-width: 769px) {
            /* Auto-collapse sidebar below 1200px on tablets/smaller desktops */
            .sidebar.auto-collapsed {
                width: 0;
                min-width: 0;
                border-right: none;
            }
            
            .sidebar.auto-collapsed .sidebar-header,
            .sidebar.auto-collapsed .sidebar-content {
                opacity: 0;
                visibility: hidden;
            }
            
            .sidebar-toggle.auto-mode {
                left: 0;
            }
            
            .sidebar-toggle.auto-mode i {
                transform: rotate(0deg);
            }
        }
        
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Mobile Panel Toggle Buttons */
        .mobile-panel-toggles {
            display: none;
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            gap: 12px;
        }
        
        .mobile-toggle-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #00a9e0, #0077b6);
            color: white;
            font-size: 1.2em;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 169, 224, 0.4);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .mobile-toggle-btn:hover,
        .mobile-toggle-btn:focus {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 169, 224, 0.5);
        }
        
        .mobile-toggle-btn:active {
            transform: scale(0.95);
        }
        
        .mobile-toggle-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        
        .mobile-toggle-btn.filter-toggle {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }
        
        .mobile-toggle-btn.filter-toggle.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        
        .mobile-toggle-btn.list-toggle {
            background: linear-gradient(135deg, #00a9e0, #0077b6);
            box-shadow: 0 4px 15px rgba(0, 169, 224, 0.4);
        }
        
        .mobile-toggle-btn.list-toggle.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }
        
        /* Mobile Panel Close Button */
        .mobile-panel-close {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: rgba(231, 76, 60, 0.9);
            color: white;
            font-size: 1em;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .mobile-panel-close:hover {
            background: #e74c3c;
            transform: scale(1.1);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                position: relative;
            }
            
            .sidebar {
                position: fixed;
                width: 100%;
                height: 100vh;
                height: 100dvh;
                top: 0;
                left: 0;
                z-index: 1001;
                transform: translateY(100%);
                /* No transition by default on mobile - prevents flickering during breakpoint change */
                transition: none;
                display: flex;
                flex-direction: column;
            }
            
            /* Only enable transition when actually visible and animating */
            .sidebar.mobile-transitioning {
                transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            }
            
            /* Disable transitions during responsive breakpoint changes */
            .sidebar.no-transition {
                transition: none !important;
            }
            
            .sidebar.mobile-visible {
                transform: translateY(0);
            }
            
            .sidebar-content {
                flex-direction: column;
                flex: 1;
                overflow: hidden;
            }
            
            .filters-panel {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #0f3460;
                display: none;
                flex: 1;
                overflow-y: auto;
            }
            
            .filters-panel.mobile-active {
                display: block;
            }
            
            .stations-list {
                width: 100%;
                display: none;
                flex: 1;
                overflow: hidden;
            }
            
            .stations-list.mobile-active {
                display: flex;
            }
            
            .map-container {
                width: 100%;
                height: 100vh;
                height: 100dvh;
                position: fixed;
                top: 0;
                left: 0;
                padding-bottom: env(safe-area-inset-bottom);
            }
            
            .mobile-panel-toggles {
                display: flex;
            }
            
            .mobile-panel-close {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Adjust stats bar for mobile - align with buttons */
            .stats-bar {
                bottom: calc(30px + env(safe-area-inset-bottom));
                min-width: 120px;
                gap: 4px;
                padding: 8px 12px;
            }
            
            .stats-bar .stat-label {
                display: inline;
                font-size: 0.85em;
            }
            
            /* Adjust search box for mobile - leave room for filter button */
            .search-box {
                left: 55px;
                right: 65px;
                width: auto;
                top: 10px;
            }
            
            /* Show mobile filter button */
            .mobile-filter-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Hide filter button from bottom panel, show only list */
            .mobile-panel-toggles .filter-toggle {
                display: none;
            }
            
            /* Hide list button when filter panel is open */
            .mobile-panel-toggles.filter-active {
                display: none;
            }
            
            /* Reduce spacing between number and unit on mobile */
            .stat {
                gap: 3px;
            }
            
            /* Hide desktop sidebar toggle on mobile */
            .sidebar-toggle {
                display: none;
            }
            
            /* Adjust legend for mobile - align with buttons */
            .map-legend {
                bottom: calc(30px + env(safe-area-inset-bottom));
                right: 10px;
                font-size: 0.8em;
                padding: 10px 12px;
                border-radius: 10px;
                min-width: 120px;
            }
            
            .map-legend .legend-title {
                margin-bottom: 6px;
                font-size: 0.95em;
            }
            
            .map-legend .legend-item {
                margin-bottom: 3px;
            }
            
            .map-legend .legend-color {
                width: 16px;
                height: 10px;
            }
            
            /* Move toggle buttons to center bottom */
            .mobile-panel-toggles {
                bottom: calc(30px + env(safe-area-inset-bottom));
            }
            
            /* Mobile panel header with close button */
            .sidebar-header {
                position: relative;
                padding-right: 50px;
            }
        }
        
        @media (max-width: 420px) {
            .mobile-toggle-btn {
                width: 50px;
                height: 50px;
                font-size: 1.1em;
            }
            
            /* Stats and legend boxes align with buttons */
            .stats-bar {
                bottom: calc(25px + env(safe-area-inset-bottom));
                gap: 3px;
                padding: 6px 10px;
                font-size: 0.75em;
                min-width: 110px;
            }
            
            .stats-bar .stat-value {
                min-width: 40px;
            }
            
            .stat {
                gap: 2px;
            }
            
            .search-box {
                left: 50px;
                right: 60px;
            }
            
            .search-box input {
                padding: 8px 10px;
                font-size: 0.8em;
            }
            
            .map-legend {
                bottom: calc(25px + env(safe-area-inset-bottom));
                font-size: 0.7em;
                padding: 8px 10px;
                min-width: 110px;
            }
            
            .mobile-panel-toggles {
                bottom: calc(25px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1><i class="fas fa-charging-station"></i> Charge Price Map</h1>
                <p>ChargeMyHyundai Preisübersicht</p>
                <button class="mobile-panel-close" id="mobilePanelClose" aria-label="Panel schließen" title="Schließen">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- Sidebar Content: Filter + List side by side -->
            <div class="sidebar-content">
            
            <!-- Filters Panel -->
            <div class="filters-panel" id="filters-tab">
                <!-- Tariff Toggle -->
                <div class="filter-group">
                    <label><i class="fas fa-tag"></i> Tarif</label>
                    <div class="tariff-toggle">
                        <button class="tariff-btn" data-tariff="HYUNDAI_FLEX">
                            Flex
                            <span class="price">0€/Monat</span>
                        </button>
                        <button class="tariff-btn active" data-tariff="HYUNDAI_SMART">
                            Smart
                            <span class="price">9,99€/Monat</span>
                        </button>
                    </div>
                </div>
                
                <!-- Power Type Toggle (Multi-Select) -->
                <div class="filter-group">
                    <label><i class="fas fa-bolt"></i> Ladetyp (Mehrfachauswahl)</label>
                    <div class="power-toggle">
                        <button class="power-btn" data-power="AC">
                            <i class="fas fa-plug"></i> AC (Typ 2)
                        </button>
                        <button class="power-btn" data-power="DC">
                            <i class="fas fa-bolt"></i> DC (CCS)
                        </button>
                    </div>
                </div>
                
                <!-- Charge Speed Selector -->
                <div class="filter-group">
                    <label for="minPower"><i class="fas fa-tachometer-alt"></i> Min. Ladeleistung</label>
                    <div class="price-slider">
                        <input type="range" id="minPower" min="0" max="350" step="50" value="0" aria-label="Minimale Ladeleistung in kW">
                        <div class="price-value">
                            <span>Alle</span>
                            <span class="current" id="minPowerValue">Alle</span>
                            <span>350 kW</span>
                        </div>
                    </div>
                </div>
                
                <!-- Max Price Filter -->
                <div class="filter-group">
                    <label for="maxPrice"><i class="fas fa-euro-sign"></i> Max. Preis (€/kWh) - nur EUR</label>
                    <div class="price-slider">
                        <input type="range" id="maxPrice" min="0.20" max="1.50" step="0.01" value="1.50" aria-label="Maximaler Preis pro kWh">
                        <div class="price-value">
                            <span>0,20€</span>
                            <span class="current" id="maxPriceValue">1,50€</span>
                            <span>1,50€</span>
                        </div>
                    </div>
                </div>
                
                <!-- Additional Filters -->
                <div class="filter-group">
                    <label><i class="fas fa-sliders-h"></i> Weitere Filter</label>
                    <div class="filter-chips">
                        <button class="filter-chip" data-filter="available">
                            <i class="fas fa-check-circle"></i> Verfügbar
                        </button>
                        <button class="filter-chip" data-filter="24h">
                            <i class="fas fa-clock"></i> 24h
                        </button>
                    </div>
                </div>
                
                <!-- Operator Filter -->
                <div class="filter-group">
                    <label><i class="fas fa-building"></i> Betreiber (CPO)</label>
                    <div class="operator-filter">
                        <div class="operator-filter-header">
                            <button class="operator-filter-btn active-include" id="includeMode">
                                <i class="fas fa-plus-circle"></i> Include
                            </button>
                            <button class="operator-filter-btn" id="excludeMode">
                                <i class="fas fa-minus-circle" aria-hidden="true"></i> Exclude
                            </button>
                            <button class="operator-filter-btn" id="clearOperators" aria-label="Filter zurücksetzen" title="Filter zurücksetzen">
                                <i class="fas fa-times" aria-hidden="true"></i>
                            </button>
                        </div>
                        <div class="operator-tags" id="operatorTags">
                            <span class="operator-tag placeholder">Lade Betreiber...</span>
                        </div>
                        <div class="operator-expand-container" id="operatorExpandContainer"></div>
                    </div>
                </div>
            </div>
            
            <!-- Stations List -->
            <div class="stations-list" id="list-tab">
                <div class="list-header-fixed">
                    <span id="listCount">0 Stationen</span>
                    <label for="sortSelect" class="visually-hidden">Sortierung</label>
                    <select class="sort-select" id="sortSelect" aria-label="Sortierung">
                        <option value="price-asc">Preis ↑</option>
                        <option value="price-desc">Preis ↓</option>
                        <option value="cpo-asc">Betreiber A-Z</option>
                        <option value="cpo-desc">Betreiber Z-A</option>
                    </select>
                </div>
                <div class="list-scroll-container">
                    <div class="loading" id="list-loading">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Lade Stationen...</p>
                    </div>
                    <div id="stations-container"></div>
                </div>
            </div>
            </div><!-- End sidebar-content -->
        </div>
        
        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
            
            <!-- Loading Overlay -->
            <div class="loading-overlay" id="loadingOverlay">
                <i class="fas fa-spinner fa-spin"></i>
                <span>Lade Preise...</span>
            </div>
            
            <!-- Search Box -->
            <div class="search-box">
                <label for="searchInput" class="visually-hidden">Adresse suchen</label>
                <input type="text" id="searchInput" placeholder="Adresse suchen..." aria-label="Adresse suchen">
                <button id="searchBtn" aria-label="Suchen" title="Suchen"><i class="fas fa-search" aria-hidden="true"></i></button>
            </div>
            
            <!-- Mobile Filter Button (top right) -->
            <button class="mobile-filter-btn" id="mobileFilterBtn" aria-label="Filter anzeigen" title="Filter">
                <i class="fas fa-filter"></i>
            </button>
            
            <!-- Stats Bar -->
            <div class="stats-bar">
                <div class="stat">
                    <i class="fas fa-charging-station"></i>
                    <span class="stat-value" id="stationCount">0</span>
                    <span class="stat-label">Stationen</span>
                </div>
                <div class="stat">
                    <i class="fas fa-euro-sign"></i>
                    <span class="stat-value" id="avgPrice">-</span>
                    <span class="stat-label">Ø&nbsp;Preis</span>
                </div>
                <div class="stat">
                    <i class="fas fa-arrow-down"></i>
                    <span class="stat-value" id="minPrice">-</span>
                    <span class="stat-label">Min</span>
                </div>
            </div>
            
            <!-- Legend -->
            <div class="map-legend">
                <div class="legend-title">Preis/kWh (EUR)</div>
                <div class="legend-item">
                    <div class="legend-color cheap"></div>
                    <span>&lt; 0,45€</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color moderate"></div>
                    <span>0,45€ - 0,60€</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color expensive"></div>
                    <span>&gt; 0,60€</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color foreign"></div>
                    <span>Andere Währung</span>
                </div>
            </div>
        </div>
        
        <!-- Mobile Panel Toggle Buttons -->
        <div class="mobile-panel-toggles">
            <button class="mobile-toggle-btn filter-toggle" id="mobileFilterToggle" aria-label="Filter anzeigen" title="Filter">
                <i class="fas fa-filter"></i>
            </button>
            <button class="mobile-toggle-btn list-toggle" id="mobileListToggle" aria-label="Stationsliste anzeigen" title="Stationsliste">
                <i class="fas fa-list"></i>
            </button>
        </div>
        
        <!-- Desktop Sidebar Toggle Button -->
        <button class="sidebar-toggle sidebar-open" id="sidebarToggle" aria-label="Seitenleiste ein-/ausblenden" title="Seitenleiste ein-/ausblenden">
            <i class="fas fa-chevron-left"></i>
        </button>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <script>
        // State
        let map;
        let markersLayer;
        let stations = [];
        let operators = {};  // CPO ID -> name mapping
        let poolDetails = {}; // Pool ID -> {cpo_name, location_name, street, city}
        let currentTariff = 'HYUNDAI_SMART';
        let selectedPowerTypes = new Set(); // Empty = show both AC and DC (no filter)
        let currentLocationMarker = null;  // Marker for user's current location
        let searchMarker = null;  // Marker for searched address
        
        // Helper: get effective power types (empty set means both)
        function getEffectivePowerTypes() {
            return selectedPowerTypes.size === 0 ? ['AC', 'DC'] : Array.from(selectedPowerTypes);
        }
        let minChargePower = 0;
        let maxPriceFilter = 1.50;
        let includedOperators = new Set();
        let excludedOperators = new Set();
        let operatorFilterMode = 'include';  // 'include' or 'exclude'
        let currentSortMode = 'price-asc';
        let currentMarket = 'de';
        let activeFilters = {
            available: false,
            '24h': false
        };
        let priceCache = {};
        let markerMap = {};  // station.id -> marker
        let markerPriceHash = {};  // station.id -> price hash (to detect changes)
        let openPopupStationId = null;  // Track which station has open popup
        let availabilityInterval = null;  // Interval for refreshing availability
        let updateMarkersScheduled = false;  // Debounce flag for updateMarkers
        let updateMarkersTimeout = null;  // Timeout for debounced updateMarkers
        
        // Currency symbols
        const currencySymbols = {
            'EUR': '€',
            'USD': '$',
            'GBP': '£',
            'CHF': 'CHF',
            'PLN': 'zł',
            'CZK': 'Kč',
            'SEK': 'kr',
            'NOK': 'kr',
            'DKK': 'kr',
            'HUF': 'Ft'
        };
        
        // Default location: Passau
        const DEFAULT_LAT = 48.5665;
        const DEFAULT_LNG = 13.4314;
        const DEFAULT_ZOOM = 14;

        // Initialize map with geolocation
        function initMap() {
            // Create map with default view first (will update if geolocation succeeds)
            map = L.map('map').setView([DEFAULT_LAT, DEFAULT_LNG], DEFAULT_ZOOM);
            
            // Dark tile layer
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
            
            // Try to get user's location
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(
                    // Success callback
                    (position) => {
                        const userLat = position.coords.latitude;
                        const userLng = position.coords.longitude;
                        console.log(`Geolocation successful: ${userLat}, ${userLng}`);
                        map.setView([userLat, userLng], DEFAULT_ZOOM);
                        
                        // Add marker for current location
                        addCurrentLocationMarker(userLat, userLng);
                        
                        loadStations();
                    },
                    // Error callback - fall back to Passau
                    (error) => {
                        console.log('Geolocation error:', error.message, '- using default location (Passau)');
                        // Map already at default location, just load stations
                        loadStations();
                    },
                    // Options
                    {
                        enableHighAccuracy: false,
                        timeout: 5000,
                        maximumAge: 300000 // Cache position for 5 minutes
                    }
                );
            } else {
                console.log('Geolocation not supported - using default location (Passau)');
                loadStations();
            }
            
            // Marker cluster group
            markersLayer = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 50,
                iconCreateFunction: function(cluster) {
                    const count = cluster.getChildCount();
                    const markers = cluster.getAllChildMarkers();
                    
                    // Find lowest AC and DC prices from all stations in cluster
                    let lowestAC = Infinity;
                    let lowestDC = Infinity;
                    let currency = 'EUR';
                    
                    for (const marker of markers) {
                        if (marker.stationData) {
                            const displayPrices = getDisplayPrices(marker.stationData);
                            for (const p of displayPrices) {
                                if (p.type === 'AC' && p.energy_price < lowestAC) {
                                    lowestAC = p.energy_price;
                                    currency = p.currency || 'EUR';
                                }
                                if (p.type === 'DC' && p.energy_price < lowestDC) {
                                    lowestDC = p.energy_price;
                                    currency = p.currency || 'EUR';
                                }
                            }
                        }
                    }
                    
                    // Build cluster HTML with AC/DC price info
                    let priceLines = [];
                    let lowestPrice = Infinity;
                    
                    if (lowestAC < Infinity) {
                        priceLines.push(`AC: ${formatPrice(lowestAC, currency)}`);
                        lowestPrice = Math.min(lowestPrice, lowestAC);
                    }
                    if (lowestDC < Infinity) {
                        priceLines.push(`DC: ${formatPrice(lowestDC, currency)}`);
                        lowestPrice = Math.min(lowestPrice, lowestDC);
                    }
                    
                    let clusterHtml = '';
                    if (priceLines.length > 0) {
                        const priceClass = getPriceClass(lowestPrice, currency);
                        clusterHtml = `<div class="cluster-marker ${priceClass}">
                            <span class="cluster-count">${count} <span style="font-size: 0.7em; font-weight: normal;">ab</span></span>
                            <span class="cluster-price">${priceLines.join('<br>')}</span>
                        </div>`;
                    } else {
                        clusterHtml = `<div class="cluster-marker"><span class="cluster-count">${count}</span></div>`;
                    }
                    
                    const hasMultipleLines = priceLines.length > 1;
                    return L.divIcon({
                        html: clusterHtml,
                        className: 'custom-cluster',
                        iconSize: [75, hasMultipleLines ? 50 : 40]
                    });
                }
            });
            map.addLayer(markersLayer);
            
            // Load stations on map move
            map.on('moveend', debounce(loadStations, 500));
            map.on('zoomend', debounce(loadStations, 500));
            
            // Update marker visibility when viewport changes (for culling)
            map.on('moveend', debounce(updateMarkers, 100));
            
            // Note: Initial loadStations() is called in geolocation success/error callbacks
        }
        
        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Helper function to escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to validate hex color
        function isValidColor(color) {
            // Check if it's a valid hex color
            return /^#[0-9A-F]{6}$/i.test(color);
        }
        
        // Helper function to validate RGB values
        function isValidRgb(rgb) {
            // Check if it's valid RGB values (e.g., "52, 152, 219")
            const parts = rgb.split(',').map(p => p.trim());
            if (parts.length !== 3) return false;
            return parts.every(p => {
                const num = parseInt(p, 10);
                return !isNaN(num) && num >= 0 && num <= 255;
            });
        }
        
        // Helper function to create a custom location marker icon
        function createLocationMarkerIcon(iconClass, gradientStart, gradientEnd, shadowColor) {
            // Validate icon class - only allow known Font Awesome classes
            const allowedIcons = ['fa-location-arrow', 'fa-search'];
            if (!allowedIcons.includes(iconClass)) {
                iconClass = 'fa-location-arrow';  // Use first allowed icon as fallback
            }
            
            // Validate colors
            if (!isValidColor(gradientStart)) gradientStart = '#3498db';
            if (!isValidColor(gradientEnd)) gradientEnd = '#2980b9';
            if (!isValidRgb(shadowColor)) shadowColor = '52, 152, 219';
            
            return L.divIcon({
                html: `<div style="background: linear-gradient(135deg, ${gradientStart}, ${gradientEnd}); color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(${shadowColor}, 0.6); border: 3px solid white;"><i class="fas ${iconClass}" style="font-size: 14px;"></i></div>`,
                className: 'custom-location-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }
        
        // Add marker for current location
        function addCurrentLocationMarker(lat, lng) {
            // Remove existing current location marker if it exists
            if (currentLocationMarker) {
                map.removeLayer(currentLocationMarker);
            }
            
            // Create a blue marker with a location arrow icon for current location
            const currentLocationIcon = createLocationMarkerIcon('fa-location-arrow', '#3498db', '#2980b9', '52, 152, 219');
            
            currentLocationMarker = L.marker([lat, lng], { icon: currentLocationIcon })
                .bindPopup('<div class="popup-content"><div class="popup-title"><i class="fas fa-location-arrow"></i> Ihr Standort</div><div class="popup-address">Aktuelle Position</div></div>')
                .addTo(map);
        }
        
        // Add marker for searched address
        function addSearchMarker(lat, lng, address) {
            // Remove existing search marker if it exists
            if (searchMarker) {
                map.removeLayer(searchMarker);
            }
            
            // Create a red marker with a search icon for searched location
            const searchIcon = createLocationMarkerIcon('fa-search', '#e74c3c', '#c0392b', '231, 76, 60');
            
            // Escape address to prevent XSS
            const safeAddress = escapeHtml(address);
            
            searchMarker = L.marker([lat, lng], { icon: searchIcon })
                .bindPopup(`<div class="popup-content"><div class="popup-title"><i class="fas fa-search"></i> Gesuchter Ort</div><div class="popup-address">${safeAddress}</div></div>`)
                .addTo(map);
        }
        
        // Show/hide loading overlay
        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.add('visible');
            } else {
                overlay.classList.remove('visible');
            }
        }
        
        // Detect market from coordinates
        function detectMarket(lat, lng) {
            if (lat >= 47 && lat <= 55 && lng >= 5.5 && lng <= 15) return 'de';
            if (lat >= 46 && lat <= 49 && lng >= 5.5 && lng <= 10.5) return 'ch';
            if (lat >= 46.5 && lat <= 49 && lng >= 9.5 && lng <= 17) return 'at';
            if (lat >= 49.5 && lat <= 51.5 && lng >= 2 && lng <= 6.5) return 'be';
            if (lat >= 50.5 && lat <= 53.5 && lng >= 3.3 && lng <= 7.2) return 'nl';
            if (lat >= 41 && lat <= 51 && lng >= -5.5 && lng <= 9.5) return 'fr';
            if (lat >= 36 && lat <= 44 && lng >= -9.5 && lng <= 4) return 'es';
            if (lat >= 36 && lat <= 47 && lng >= 6 && lng <= 19) return 'it';
            if (lat >= 49 && lat <= 54.5 && lng >= 14 && lng <= 24) return 'pl';
            if (lat >= 47.5 && lat <= 51 && lng >= 12 && lng <= 22.5) return 'cz';
            if (lat >= 55 && lat <= 58 && lng >= 8 && lng <= 13) return 'dk';
            if (lat >= 55 && lat <= 69 && lng >= 4.5 && lng <= 31) return 'no';
            if (lat >= 55 && lat <= 69 && lng >= 11 && lng <= 24) return 'se';
            if (lat >= 50 && lat <= 56 && lng >= -11 && lng <= 2) return 'gb';
            return 'de';
        }
        
        // Track which stations are already loaded (by ID)
        let loadedStationIds = new Set();
        let isInitialLoad = true;
        
        // Load stations for current map bounds
        async function loadStations() {
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            const center = map.getCenter();
            
            // Detect market based on map center
            currentMarket = detectMarket(center.lat, center.lng);
            
            // Calculate precision based on zoom level
            let precision = Math.min(10, Math.max(3, zoom - 5));
            
            const boundsParams = `lat_nw=${bounds.getNorth()}&lng_nw=${bounds.getWest()}&lat_se=${bounds.getSouth()}&lng_se=${bounds.getEast()}`;
            
            try {
                // STEP 1: Load cached stations first (fast, instant display)
                if (isInitialLoad) {
                    showLoading(true);
                    try {
                        const cacheResponse = await fetch(`/api/cached-stations?${boundsParams}&market=${currentMarket}`);
                        const cacheData = await cacheResponse.json();
                        
                        if (cacheData.stations && cacheData.stations.length > 0) {
                            console.log(`Loaded ${cacheData.stations.length} cached stations`);
                            
                            // Add cached stations to the stations array
                            for (const cachedStation of cacheData.stations) {
                                if (!loadedStationIds.has(cachedStation.id)) {
                                    loadedStationIds.add(cachedStation.id);
                                    stations.push(cachedStation);
                                }
                            }
                            
                            // Update UI immediately with cached data
                            updateOperatorList();
                            updateMarkers();
                            updateList();
                            updateStats();
                            
                            // Start loading prices in background
                            loadPrices();
                        }
                    } catch (cacheError) {
                        console.warn('Could not load cached stations:', cacheError);
                    }
                    isInitialLoad = false;
                }
                
                // STEP 2: Load fresh stations from API (may have new stations)
                const response = await fetch(`/api/stations?${boundsParams}&precision=${precision}&market=${currentMarket}`);
                const data = await response.json();
                
                if (data.error) {
                    console.error('API Error:', data.error);
                    return;
                }
                
                const apiStations = data.pools || [];
                let newStationsCount = 0;
                
                // Merge API stations with existing (avoid duplicates)
                for (const apiStation of apiStations) {
                    if (!loadedStationIds.has(apiStation.id)) {
                        loadedStationIds.add(apiStation.id);
                        stations.push(apiStation);
                        newStationsCount++;
                    } else {
                        // Update existing station with fresh API data
                        const existingIndex = stations.findIndex(s => s.id === apiStation.id);
                        if (existingIndex !== -1) {
                            // Merge: keep cached data but update with API data
                            stations[existingIndex] = {
                                ...stations[existingIndex],
                                ...apiStation,
                                // Keep prices if already loaded
                                prices: stations[existingIndex].prices || {}
                            };
                        }
                    }
                }
                
                if (newStationsCount > 0) {
                    console.log(`Added ${newStationsCount} new stations from API`);
                }
                
                // Extract CPO info
                updateOperatorList();
                
                // Preload all cached prices (for both tariffs) for fast switching
                await preloadCachedPrices();
                
                // Get prices for all charge points (will use cache, only fetch missing)
                await loadPrices();
                
                // Update map and list
                updateMarkers();
                updateList();
                updateStats();
                
            } catch (error) {
                console.error('Error loading stations:', error);
            }
        }
        
        // Update operator list from stations
        function updateOperatorList() {
            for (const station of stations) {
                if (station.dcsTechnicalChargePointOperatorId) {
                    const cpoId = station.dcsTechnicalChargePointOperatorId;
                    if (!operators[cpoId]) {
                        // Fallback name until we get real name from API
                        const parts = cpoId.split(':');
                        const shortId = parts[parts.length - 1].substring(0, 8);
                        operators[cpoId] = `CPO-${shortId}`;
                    }
                }
            }
            renderOperatorTags();
            
            // Load pool details in background for real CPO names
            loadPoolDetails();
        }
        
        // Load pool details for real CPO names and addresses
        async function loadPoolDetails() {
            // Collect pool IDs we don't have details for yet
            // Note: API returns pool ID in 'id' field, not 'dcsPoolId'
            const poolIdsToFetch = [];
            for (const station of stations) {
                const poolId = station.id;  // Pool ID is in 'id' field
                if (poolId && !poolDetails[poolId]) {
                    poolIdsToFetch.push(poolId);
                }
            }
            
            if (poolIdsToFetch.length === 0) return;
            
            console.log(`Loading pool details for ${poolIdsToFetch.length} stations...`);
            
            try {
                const response = await fetch('/api/pool-details', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        pool_ids: poolIdsToFetch,
                        market: currentMarket
                    })
                });
                
                if (!response.ok) {
                    console.error('Pool details API error:', response.status);
                    return;
                }
                
                const data = await response.json();
                console.log(`Got pool details for ${Object.keys(data).length} stations`);
                
                // Store pool details and update operator names
                for (const [poolId, details] of Object.entries(data)) {
                    poolDetails[poolId] = details;
                    
                    // Find station with this pool ID to get CPO ID
                    const station = stations.find(s => s.id === poolId);
                    if (station && station.dcsTechnicalChargePointOperatorId && details.cpo_name) {
                        operators[station.dcsTechnicalChargePointOperatorId] = details.cpo_name;
                    }
                }
                
                // Re-render with real names
                renderOperatorTags();
                updateList();
                updateMarkers();
                
            } catch (error) {
                console.error('Error loading pool details:', error);
            }
        }
        
        // Render operator tags
        let showAllOperators = false;
        
        function renderOperatorTags() {
            const container = document.getElementById('operatorTags');
            const expandContainer = document.getElementById('operatorExpandContainer');
            const operatorIds = Object.keys(operators).sort((a, b) => 
                operators[a].localeCompare(operators[b])
            );
            
            if (operatorIds.length === 0) {
                container.innerHTML = '<span class="operator-tag placeholder">Keine Betreiber gefunden</span>';
                container.classList.remove('expanded');
                expandContainer.innerHTML = '';
                return;
            }
            
            // Always render all operators
            container.innerHTML = operatorIds.map(id => {
                let cls = 'operator-tag';
                if (includedOperators.has(id)) cls += ' included';
                if (excludedOperators.has(id)) cls += ' excluded';
                return `<span class="${cls}" data-cpo="${id}">${operators[id]}</span>`;
            }).join('');
            
            // Toggle expanded class based on state
            if (showAllOperators) {
                container.classList.add('expanded');
                expandContainer.innerHTML = `<span class="operator-tag expand-more" id="collapseOperators">weniger anzeigen</span>`;
            } else {
                container.classList.remove('expanded');
                // Check if content overflows
                if (container.scrollHeight > container.clientHeight) {
                    // Count visible operators (approximate based on height)
                    const hiddenCount = operatorIds.length - Math.floor(operatorIds.length * (container.clientHeight / container.scrollHeight));
                    expandContainer.innerHTML = `<span class="operator-tag expand-more" id="expandOperators">+${hiddenCount > 0 ? hiddenCount : '...'} weitere</span>`;
                } else {
                    expandContainer.innerHTML = '';
                }
            }
            
            // Add click handlers for operator tags
            container.querySelectorAll('.operator-tag[data-cpo]').forEach(tag => {
                tag.addEventListener('click', () => {
                    const cpoId = tag.dataset.cpo;
                    toggleOperator(cpoId);
                });
            });
            
            // Add click handler for expand/collapse
            const expandBtn = document.getElementById('expandOperators');
            if (expandBtn) {
                expandBtn.addEventListener('click', () => {
                    showAllOperators = true;
                    renderOperatorTags();
                });
            }
            const collapseBtn = document.getElementById('collapseOperators');
            if (collapseBtn) {
                collapseBtn.addEventListener('click', () => {
                    showAllOperators = false;
                    renderOperatorTags();
                });
            }
        }
        
        // Toggle operator in filter
        function toggleOperator(cpoId) {
            if (operatorFilterMode === 'include') {
                excludedOperators.delete(cpoId);
                if (includedOperators.has(cpoId)) {
                    includedOperators.delete(cpoId);
                } else {
                    includedOperators.add(cpoId);
                }
            } else if (operatorFilterMode === 'exclude') {
                includedOperators.delete(cpoId);
                if (excludedOperators.has(cpoId)) {
                    excludedOperators.delete(cpoId);
                } else {
                    excludedOperators.add(cpoId);
                }
            }
            renderOperatorTags();
            updateMarkers();
            updateList();
            updateStats();
        }
        
        // Preload cached prices for all tariffs (called once after stations load)
        async function preloadCachedPrices() {
            const poolIds = stations.map(s => s.id).filter(id => id);
            if (poolIds.length === 0) return;
            
            try {
                const response = await fetch('/api/cached-prices', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pool_ids: poolIds,
                        market: currentMarket
                    })
                });
                
                if (!response.ok) return;
                
                const allPrices = await response.json();
                let loadedCount = 0;
                
                // Store all prices in frontend cache
                for (const [poolId, prices] of Object.entries(allPrices)) {
                    const station = stations.find(s => s.id === poolId);
                    if (!station || !station.chargePoints || station.chargePoints.length === 0) continue;
                    
                    const cpId = station.chargePoints[0].id;
                    
                    for (const [key, priceData] of Object.entries(prices)) {
                        // key format: "HYUNDAI_SMART_AC" or "HYUNDAI_FLEX_DC"
                        const parts = key.split('_');
                        const powerType = parts.pop(); // AC or DC
                        const tariffId = parts.join('_'); // HYUNDAI_SMART or HYUNDAI_FLEX
                        
                        const cacheKey = `${cpId}_${tariffId}_${powerType}_${currentMarket}`;
                        priceCache[cacheKey] = {
                            charge_point: cpId,
                            power_type: powerType,
                            currency: priceData.currency || 'EUR',
                            energy_price: priceData.energy_price,
                            session_fee: priceData.session_fee,
                            blocking_fee: priceData.blocking_fee,
                            blocking_after_minutes: priceData.blocking_after_minutes,
                            cached: true
                        };
                        loadedCount++;
                    }
                }
                
                console.log(`Preloaded ${loadedCount} prices for all tariffs from cache`);
            } catch (error) {
                console.warn('Could not preload cached prices:', error);
            }
        }
        
        // Load prices for stations (for all selected power types)
        async function loadPrices() {
            const chargePoints = [];
            const cpToStation = {};
            const cpToPoolId = {};  // Map charge point ID to pool ID for caching
            
            for (const station of stations) {
                if (station.chargePoints && station.chargePoints.length > 0) {
                    const cpId = station.chargePoints[0].id;
                    chargePoints.push(cpId);
                    cpToStation[cpId] = station;
                    cpToPoolId[cpId] = station.id;  // Map charge point to pool ID for cache
                    // Initialize prices object for both AC and DC
                    station.prices = station.prices || {};
                }
            }
            
            if (chargePoints.length === 0) return;
            
            // Load prices for each selected power type
            const powerTypesToLoad = getEffectivePowerTypes();
            
            for (const powerType of powerTypesToLoad) {
                const power = powerType === 'DC' ? 50 : 11;
                
                // Check cache first and only request uncached
                const uncached = chargePoints.filter(cp => {
                    const cacheKey = `${cp}_${currentTariff}_${powerType}_${currentMarket}`;
                    if (priceCache[cacheKey]) {
                        // Use cached price
                        const station = cpToStation[cp];
                        if (station) {
                            station.prices[powerType] = priceCache[cacheKey];
                        }
                        return false;
                    }
                    return true;
                });
                
                if (uncached.length === 0) continue;
                
                // Limit to first 100 to avoid rate limiting
                const toFetch = uncached.slice(0, 100);
                showLoading(true);
                
                // Split into larger batches of 15 for faster loading
                const batchSize = 15;
                const maxConcurrent = 5;
                
                // Create batches
                const batches = [];
                for (let i = 0; i < toFetch.length; i += batchSize) {
                    batches.push({
                        cps: toFetch.slice(i, i + batchSize),
                        poolIds: toFetch.slice(i, i + batchSize).map(cp => cpToPoolId[cp])
                    });
                }
                
                // Process batches with concurrency limit
                let activePromises = [];
                for (const batch of batches) {
                    const fetchPromise = fetch('/api/prices', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            charge_points: batch.cps,
                            pool_ids: batch.poolIds,
                            tariff_id: currentTariff,
                            power_type: powerType,
                            power: power,
                            market: currentMarket
                        })
                    }).then(r => r.json()).then(prices => {
                        if (Array.isArray(prices)) {
                            for (const price of prices) {
                                if (price.charge_point) {
                                    const cacheKey = `${price.charge_point}_${currentTariff}_${powerType}_${currentMarket}`;
                                    priceCache[cacheKey] = price;
                                    const station = cpToStation[price.charge_point];
                                    if (station) {
                                        station.prices[powerType] = price;
                                    }
                                }
                            }
                        }
                        // Update UI progressively
                        updateMarkers();
                        updateList();
                        updateStats();
                    }).catch(error => console.error('Error loading prices:', error));
                    
                    activePromises.push(fetchPromise);
                    
                    // Wait if we hit max concurrent
                    if (activePromises.length >= maxConcurrent) {
                        await Promise.race(activePromises);
                        activePromises = activePromises.filter(p => !p.settled);
                    }
                }
                
                // Wait for remaining
                await Promise.allSettled(activePromises);
            }
            
            showLoading(false);
        }
        
        // Get price class for styling
        function getPriceClass(price, currency) {
            if (currency !== 'EUR') return 'foreign';
            if (price < 0.45) return 'cheap';
            if (price < 0.60) return 'moderate';
            return 'expensive';
        }
        
        // Format price with currency
        function formatPrice(price, currency = 'EUR') {
            const symbol = currencySymbols[currency] || currency;
            return price.toFixed(2).replace('.', ',') + symbol;
        }
        
        // Format blocking fee for display
        function formatBlockingFee(price) {
            if (!price || !price.blocking_fee) return null;
            
            const currency = price.currency || 'EUR';
            const feePerHour = price.blocking_fee;
            const afterMinutes = price.blocking_after_minutes || 0;
            
            // Convert to per-minute fee for display (fee is per hour)
            const feePerMinute = feePerHour / 60;
            
            if (afterMinutes > 0) {
                return `${formatPrice(feePerMinute, currency)}/min ab ${afterMinutes} min`;
            } else {
                return `${formatPrice(feePerMinute, currency)}/min Standgebühr`;
            }
        }
        
        // Format cache info for display
        function formatCacheInfo(details) {
            if (!details || !details.updated_at) return null;
            
            const updatedAt = new Date(details.updated_at);
            const now = new Date();
            const ageMs = now - updatedAt;
            const ageHours = ageMs / (1000 * 60 * 60);
            const ageDays = ageHours / 24;
            
            let text = '';
            let stale = false;
            
            if (ageHours < 1) {
                const ageMinutes = Math.floor(ageMs / (1000 * 60));
                text = `Aktualisiert vor ${ageMinutes} Minuten`;
            } else if (ageHours < 24) {
                text = `Aktualisiert vor ${Math.floor(ageHours)} Stunden`;
            } else {
                text = `Aktualisiert vor ${Math.floor(ageDays)} Tagen`;
                stale = true;
            }
            
            if (details.cached) {
                text = `📦 ${text}`;
            }
            
            return { text, stale };
        }
        
        // Refresh station data (manual update button)
        async function refreshStation(stationId, market) {
            const btn = document.getElementById(`refresh-btn-${stationId}`);
            const cacheInfo = document.getElementById(`cache-info-${stationId}`);
            
            if (!btn) return;
            
            // Show loading state
            btn.disabled = true;
            btn.classList.add('loading');
            btn.innerHTML = '<i class="fas fa-sync-alt"></i> Aktualisiere...';
            
            try {
                const response = await fetch('/api/cache/refresh', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pool_id: stationId, market: market })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update pool details cache for THIS station only
                    if (result.station) {
                        poolDetails[stationId] = result.station;
                    }
                    
                    // Update prices for THIS station only (don't clear entire cache)
                    if (result.prices) {
                        const station = stations.find(s => s.id === stationId);
                        if (station && station.chargePoints && station.chargePoints.length > 0) {
                            const cpId = station.chargePoints[0].id;
                            // Update AC and DC prices from response
                            for (const [key, price] of Object.entries(result.prices)) {
                                const [tariff, powerType] = key.split('_');
                                if (tariff === currentTariff) {
                                    const cacheKey = `${cpId}_${currentTariff}_${powerType}_${currentMarket}`;
                                    priceCache[cacheKey] = price;
                                    station.prices[powerType] = price;
                                }
                            }
                        }
                    }
                    
                    // Update UI
                    updateMarkers();
                    updateList();
                    updateStats();
                    
                    btn.innerHTML = '<i class="fas fa-check"></i> Aktualisiert!';
                    btn.style.borderColor = '#2ecc71';
                    btn.style.color = '#2ecc71';
                    
                    if (cacheInfo) {
                        cacheInfo.textContent = '📦 Gerade aktualisiert';
                        cacheInfo.classList.remove('stale');
                    }
                    
                    // Reset button after 2 seconds
                    setTimeout(() => {
                        btn.innerHTML = '<i class="fas fa-sync-alt"></i> Preise aktualisieren';
                        btn.style.borderColor = '';
                        btn.style.color = '';
                        btn.disabled = false;
                        btn.classList.remove('loading');
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Aktualisierung fehlgeschlagen');
                }
            } catch (error) {
                console.error('Refresh error:', error);
                
                let errorMsg = 'Fehler!';
                if (error.message && error.message.includes('rate limit')) {
                    errorMsg = 'Bitte warten...';
                }
                
                btn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${errorMsg}`;
                btn.style.borderColor = '#e74c3c';
                btn.style.color = '#e74c3c';
                
                // Reset button after 3 seconds
                setTimeout(() => {
                    btn.innerHTML = '<i class="fas fa-sync-alt"></i> Preise aktualisieren';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    btn.disabled = false;
                    btn.classList.remove('loading');
                }, 3000);
            }
        }
        
        // Check if station passes filters
        function stationPassesFilters(station) {
            // Must have at least one price for selected power types
            if (!station.prices) return false;
            
            const effectivePowerTypes = getEffectivePowerTypes();
            
            const hasValidPrice = effectivePowerTypes.some(pt => {
                const price = station.prices[pt];
                return price && price.energy_price !== null && price.energy_price !== undefined;
            });
            if (!hasValidPrice) return false;
            
            // Check price filter for at least one power type
            const passesPrice = effectivePowerTypes.some(pt => {
                const price = station.prices[pt];
                if (!price || price.energy_price === null) return false;
                const currency = price.currency || 'EUR';
                // Only apply EUR price filter to EUR prices
                if (currency === 'EUR' && price.energy_price > maxPriceFilter) return false;
                return true;
            });
            if (!passesPrice) return false;
            
            // Operator filters
            const cpoId = station.dcsTechnicalChargePointOperatorId;
            if (includedOperators.size > 0 && !includedOperators.has(cpoId)) return false;
            if (excludedOperators.has(cpoId)) return false;
            
            // Power filter - check if station has sufficient charging power
            if (minChargePower > 0) {
                const poolId = station.id;
                const poolInfo = poolDetails[poolId];
                if (poolInfo && poolInfo.max_power) {
                    if (poolInfo.max_power < minChargePower) return false;
                }
            }
            
            // Filter out CHAdeMO-only stations (check plug types)
            const poolId = station.id;
            const poolInfo = poolDetails[poolId];
            if (poolInfo && poolInfo.plug_types) {
                const hasNonChademo = poolInfo.plug_types.some(pt => {
                    const normalized = pt.toUpperCase().replace(/[\s-_]/g, '');
                    return normalized !== 'CHADEMO';
                });
                // If station ONLY has CHAdeMO, filter it out
                if (!hasNonChademo) return false;
            }
            
            return true;
        }
        
        // Check if station supports a specific power type based on plug types
        function stationSupportsPowerType(station, powerType) {
            const poolId = station.id;
            const poolInfo = poolDetails[poolId];
            
            // If we don't have plug info yet, assume it supports the power type
            if (!poolInfo || !poolInfo.plug_types || poolInfo.plug_types.length === 0) {
                return true;
            }
            
            const plugTypes = poolInfo.plug_types.map(pt => pt.toUpperCase().replace(/[\s-_]/g, ''));
            
            if (powerType === 'AC') {
                // AC = Typ 2
                return plugTypes.some(pt => pt === 'TYP2' || pt === 'TYPE2');
            } else if (powerType === 'DC') {
                // DC = CCS (not CHAdeMO)
                return plugTypes.some(pt => pt === 'CCS' || pt === 'CCS2' || pt === 'COMBO2');
            }
            
            return false;
        }
        
        // Get display prices for a station (only for power types the station actually supports)
        function getDisplayPrices(station) {
            const prices = [];
            const effectivePowerTypes = getEffectivePowerTypes();
            for (const pt of effectivePowerTypes) {
                // Only include price if station actually supports this power type
                if (!stationSupportsPowerType(station, pt)) continue;
                
                const price = station.prices[pt];
                if (price && price.energy_price !== null && price.energy_price !== undefined) {
                    prices.push({ type: pt, ...price });
                }
            }
            // Sort by price ascending
            prices.sort((a, b) => a.energy_price - b.energy_price);
            return prices;
        }
        
        // Update markers on map (debounced for performance)
        function updateMarkers() {
            // Debounce: if already scheduled, skip
            if (updateMarkersScheduled) return;
            updateMarkersScheduled = true;
            
            // Use requestAnimationFrame for smooth updates
            requestAnimationFrame(() => {
                updateMarkersScheduled = false;
                _updateMarkersInternal();
            });
        }
        
        // Internal marker update (called via debounce)
        function _updateMarkersInternal() {
            // Track which stations should be visible
            const visibleStationIds = new Set();
            const bounds = map.getBounds();
            // Expand bounds slightly to prevent markers from disappearing too early when panning
            const expandedBounds = bounds.pad(0.2);
            
            // Batch marker additions for better performance
            const markersToAdd = [];
            
            for (const station of stations) {
                // Skip stations outside expanded visible bounds (viewport culling)
                if (!expandedBounds.contains([station.latitude, station.longitude])) {
                    continue;
                }
                
                if (!stationPassesFilters(station)) continue;
                
                const displayPrices = getDisplayPrices(station);
                if (displayPrices.length === 0) continue;
                
                // Create a hash of the price data to detect changes
                const priceHash = displayPrices.map(p => `${p.type}:${p.energy_price}`).join('|');
                const existingMarker = markerMap[station.id];
                
                // If marker exists and price hasn't changed, skip update
                if (existingMarker && markerPriceHash[station.id] === priceHash) {
                    visibleStationIds.add(station.id);
                    continue;
                }
                
                markerPriceHash[station.id] = priceHash;
                
                // Create or update marker
                let marker = markerMap[station.id];
                const isNewMarker = !marker;
                
                // Only create icon and popup content for new markers or price changes
                const icon = createMarkerIcon(displayPrices);
                const popupContent = createPopupContent(station, displayPrices);
                
                if (isNewMarker) {
                    marker = L.marker([station.latitude, station.longitude], { icon });
                    marker.stationData = station;
                    marker.bindPopup(popupContent, {
                        closeOnClick: false,
                        autoClose: true
                    });
                    setupMarkerEvents(marker, station);
                    markersToAdd.push(marker);
                    markerMap[station.id] = marker;
                } else {
                    // Update existing marker
                    marker.setIcon(icon);
                    if (!marker.isPopupOpen || !marker.isPopupOpen()) {
                        marker.setPopupContent(popupContent);
                    }
                }
                
                visibleStationIds.add(station.id);
            }
            
            // Batch add new markers for better performance
            if (markersToAdd.length > 0) {
                markersLayer.addLayers(markersToAdd);
            }
            
            // Collect markers to remove
            const markersToRemove = [];
            for (const stationId in markerMap) {
                if (!visibleStationIds.has(stationId)) {
                    markersToRemove.push(markerMap[stationId]);
                    delete markerMap[stationId];
                    delete markerPriceHash[stationId];
                }
            }
            
            // Batch remove markers for better performance
            if (markersToRemove.length > 0) {
                markersLayer.removeLayers(markersToRemove);
            }
            
            // Reopen popup if one was open
            if (openPopupStationId && markerMap[openPopupStationId]) {
                const markerToOpen = markerMap[openPopupStationId];
                if (!markerToOpen.isPopupOpen || !markerToOpen.isPopupOpen()) {
                    markerToOpen.openPopup();
                }
            }
        }
        
        // Create marker icon (separated for performance)
        function createMarkerIcon(displayPrices) {
            let markerHtml = '';
            if (displayPrices.length === 1) {
                const p = displayPrices[0];
                const priceClass = getPriceClass(p.energy_price, p.currency || 'EUR');
                markerHtml = `<div class="price-marker ${priceClass}">${p.type}: ${formatPrice(p.energy_price, p.currency || 'EUR')}</div>`;
            } else {
                const acPrice = displayPrices.find(p => p.type === 'AC');
                const dcPrice = displayPrices.find(p => p.type === 'DC');
                let lines = [];
                if (acPrice) lines.push(`AC: ${formatPrice(acPrice.energy_price, acPrice.currency || 'EUR')}`);
                if (dcPrice) lines.push(`DC: ${formatPrice(dcPrice.energy_price, dcPrice.currency || 'EUR')}`);
                const lowest = displayPrices[0];
                const priceClass = getPriceClass(lowest.energy_price, lowest.currency || 'EUR');
                markerHtml = `<div class="price-marker dual ${priceClass}">${lines.join('<br>')}</div>`;
            }
            
            return L.divIcon({
                html: markerHtml,
                className: 'custom-price-marker',
                iconSize: [70, displayPrices.length > 1 ? 36 : 24],
                iconAnchor: [35, displayPrices.length > 1 ? 18 : 12]
            });
        }
        
        // Create popup content (separated for performance)
        function createPopupContent(station, displayPrices) {
            const cpoId = station.dcsTechnicalChargePointOperatorId;
            const cpoName = operators[cpoId] || 'Unbekannt';
            
            // Build popup price columns for AC and DC side by side
            const acPrice = displayPrices.find(p => p.type === 'AC');
            const dcPrice = displayPrices.find(p => p.type === 'DC');
            
            // Get charge points by type from pool details
            const stationPoolDetails = poolDetails[station.id] || {};
            const acChargePoints = stationPoolDetails.charge_points_ac || [];
            const dcChargePoints = stationPoolDetails.charge_points_dc || [];
            
            let priceColumns = '';
            if (acPrice) {
                const currency = acPrice.currency || 'EUR';
                const acTotal = acChargePoints.length;
                const blockingInfo = formatBlockingFee(acPrice);
                priceColumns += `
                    <div class="popup-price-column ac">
                        <div class="popup-price-type"><i class="fas fa-plug"></i> AC</div>
                        <div class="popup-price-main">${formatPrice(acPrice.energy_price, currency)}/kWh</div>
                        ${acPrice.session_fee ? `<div class="popup-price-fee">+ ${formatPrice(acPrice.session_fee, currency)} Start</div>` : ''}
                        ${blockingInfo ? `<div class="popup-price-blocking"><i class="fas fa-clock"></i> ${blockingInfo}</div>` : ''}
                        ${acTotal > 0 ? `<div class="popup-price-avail" id="avail-ac-${station.id}"><i class="fas fa-spinner fa-spin" style="color: #888"></i> <span style="color: #888">?/${acTotal}</span></div>` : ''}
                    </div>
                `;
            }
            if (dcPrice) {
                const currency = dcPrice.currency || 'EUR';
                const dcTotal = dcChargePoints.length;
                const blockingInfo = formatBlockingFee(dcPrice);
                priceColumns += `
                    <div class="popup-price-column dc">
                        <div class="popup-price-type"><i class="fas fa-bolt"></i> DC</div>
                        <div class="popup-price-main">${formatPrice(dcPrice.energy_price, currency)}/kWh</div>
                        ${dcPrice.session_fee ? `<div class="popup-price-fee">+ ${formatPrice(dcPrice.session_fee, currency)} Start</div>` : ''}
                        ${blockingInfo ? `<div class="popup-price-blocking"><i class="fas fa-clock"></i> ${blockingInfo}</div>` : ''}
                        ${dcTotal > 0 ? `<div class="popup-price-avail" id="avail-dc-${station.id}"><i class="fas fa-spinner fa-spin" style="color: #888"></i> <span style="color: #888">?/${dcTotal}</span></div>` : ''}
                    </div>
                `;
            }
            
            // Get pool details for popup
            const popupDetails = poolDetails[station.id] || {};
            const popupLocationName = popupDetails.location_name || '';
            const popupStreet = popupDetails.street || '';
            const popupCity = popupDetails.city || '';
            const popupZipCode = popupDetails.zip_code || '';
            const popupMaxPower = popupDetails.max_power || 0;
            const popupPlugTypes = popupDetails.plug_types || [];
            
            // Build address for popup
            let popupAddressParts = [];
            if (popupStreet) popupAddressParts.push(popupStreet);
            if (popupZipCode && popupCity) {
                popupAddressParts.push(`${popupZipCode} ${popupCity}`);
            } else if (popupCity) {
                popupAddressParts.push(popupCity);
            }
            const popupAddressStr = popupAddressParts.length > 0 
                ? popupAddressParts.join(', ')
                : `${station.latitude.toFixed(5)}, ${station.longitude.toFixed(5)}`;
            
            // Format plug types for display
            const plugTypesDisplay = popupPlugTypes
                .filter(pt => pt.toUpperCase() !== 'CHADEMO')
                .map(pt => {
                    const normalized = pt.toUpperCase();
                    if (normalized.includes('CCS') || normalized.includes('COMBO')) return 'CCS';
                    if (normalized.includes('TYP2') || normalized.includes('TYPE2')) return 'Typ 2';
                    return pt;
                })
                .filter((v, i, a) => a.indexOf(v) === i)  // unique
                .join(', ');
            
            // Check if cached and format cache age
            const cacheInfo = formatCacheInfo(popupDetails);
            
            return `
                <div class="popup-content" data-station-id="${station.id}" data-market="${currentMarket}">
                    <div class="popup-title">
                        <i class="fas fa-charging-station"></i> ${cpoName}
                    </div>
                    ${popupLocationName ? `<div style="font-size: 0.9em; color: #ccc; margin-bottom: 4px;">${popupLocationName}</div>` : ''}
                    <div class="popup-address">
                        <i class="fas fa-map-marker-alt"></i> ${popupAddressStr}
                    </div>
                    <div class="popup-prices">
                        ${priceColumns}
                    </div>
                    <div class="popup-details">
                        <span><i class="fas fa-plug"></i> ${station.chargePointCount} Ladepunkte</span>
                        ${popupMaxPower > 0 ? `<span><i class="fas fa-bolt"></i> bis ${popupMaxPower} kW</span>` : ''}
                        ${plugTypesDisplay ? `<span><i class="fas fa-charging-station"></i> ${plugTypesDisplay}</span>` : ''}
                    </div>
                    <button class="popup-refresh-btn" onclick="refreshStation('${station.id}', '${currentMarket}')" id="refresh-btn-${station.id}">
                        <i class="fas fa-sync-alt"></i> Preise aktualisieren
                    </button>
                    ${cacheInfo ? `<div class="popup-cache-info ${cacheInfo.stale ? 'stale' : ''}" id="cache-info-${station.id}">${cacheInfo.text}</div>` : ''}
                </div>
            `;
        }
        
        // Setup marker event handlers (separated for reuse)
        function setupMarkerEvents(marker, station) {
            marker.on('popupopen', async () => {
                openPopupStationId = station.id;
                
                // Clear any existing interval
                if (availabilityInterval) {
                    clearInterval(availabilityInterval);
                    availabilityInterval = null;
                }
                
                // Function to load availability
                const loadAvailability = async () => {
                    try {
                        // Get charge points by type from pool details
                        const stationDetails = poolDetails[station.id] || {};
                        const acCpIds = stationDetails.charge_points_ac || [];
                        const dcCpIds = stationDetails.charge_points_dc || [];
                        const allCpIds = [...acCpIds, ...dcCpIds];
                        
                        if (allCpIds.length === 0) return;
                        
                        const response = await fetch('/api/status', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ charge_point_ids: allCpIds })
                        });
                        
                        if (!response.ok) throw new Error('Status API error');
                        
                        const statuses = await response.json();
                        
                        // Count available AC charge points
                        let acAvailable = 0;
                        for (const cpId of acCpIds) {
                            const status = statuses[cpId];
                            if (status && status.status === 'AVAILABLE') {
                                acAvailable++;
                            }
                        }
                        
                        // Count available DC charge points
                        let dcAvailable = 0;
                        for (const cpId of dcCpIds) {
                            const status = statuses[cpId];
                            if (status && status.status === 'AVAILABLE') {
                                dcAvailable++;
                            }
                        }
                        
                        // Update AC availability display
                        const acElem = document.getElementById(`avail-ac-${station.id}`);
                        if (acElem && acCpIds.length > 0) {
                            const icon = acAvailable > 0 ? 'fa-check-circle' : 'fa-times-circle';
                            const color = acAvailable > 0 ? '#2ecc71' : '#e74c3c';
                            acElem.innerHTML = `<i class="fas ${icon}" style="color: ${color}"></i> <span style="color: ${color}">${acAvailable}/${acCpIds.length} frei</span>`;
                        }
                        
                        // Update DC availability display
                        const dcElem = document.getElementById(`avail-dc-${station.id}`);
                        if (dcElem && dcCpIds.length > 0) {
                            const icon = dcAvailable > 0 ? 'fa-check-circle' : 'fa-times-circle';
                            const color = dcAvailable > 0 ? '#2ecc71' : '#e74c3c';
                            dcElem.innerHTML = `<i class="fas ${icon}" style="color: ${color}"></i> <span style="color: ${color}">${dcAvailable}/${dcCpIds.length} frei</span>`;
                        }
                    } catch (error) {
                        console.error('Error loading availability:', error);
                        const acElem = document.getElementById(`avail-ac-${station.id}`);
                        const dcElem = document.getElementById(`avail-dc-${station.id}`);
                        if (acElem) acElem.innerHTML = `<i class="fas fa-question-circle" style="color: #888"></i> <span style="color: #888">?</span>`;
                        if (dcElem) dcElem.innerHTML = `<i class="fas fa-question-circle" style="color: #888"></i> <span style="color: #888">?</span>`;
                    }
                };
                
                // Load immediately
                loadAvailability();
                
                // Refresh every 20 seconds
                availabilityInterval = setInterval(loadAvailability, 20000);
            });
            
            marker.on('popupclose', () => {
                if (openPopupStationId === station.id) {
                    openPopupStationId = null;
                }
                // Clear interval when popup closes
                if (availabilityInterval) {
                    clearInterval(availabilityInterval);
                    availabilityInterval = null;
                }
            });
        }
        
        // Update stations list
        function updateList() {
            const container = document.getElementById('stations-container');
            const loading = document.getElementById('list-loading');
            const listCount = document.getElementById('listCount');
            
            loading.style.display = 'none';
            
            // Filter stations
            let filteredStations = stations.filter(stationPassesFilters);
            
            // Sort stations
            filteredStations.sort((a, b) => {
                const cpoA = operators[a.dcsTechnicalChargePointOperatorId] || 'ZZZ';
                const cpoB = operators[b.dcsTechnicalChargePointOperatorId] || 'ZZZ';
                
                // Get lowest price for sorting
                const pricesA = getDisplayPrices(a);
                const pricesB = getDisplayPrices(b);
                const lowestA = pricesA.length > 0 ? pricesA[0].energy_price : 999;
                const lowestB = pricesB.length > 0 ? pricesB[0].energy_price : 999;
                
                switch (currentSortMode) {
                    case 'price-asc':
                        return lowestA - lowestB;
                    case 'price-desc':
                        return lowestB - lowestA;
                    case 'cpo-asc':
                        return cpoA.localeCompare(cpoB);
                    case 'cpo-desc':
                        return cpoB.localeCompare(cpoA);
                    default:
                        return lowestA - lowestB;
                }
            });
            
            listCount.textContent = `${filteredStations.length} Stationen`;
            
            if (filteredStations.length === 0) {
                container.innerHTML = `
                    <div class="loading">
                        <i class="fas fa-search"></i>
                        <p>Keine Stationen gefunden</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = filteredStations.map(station => {
                const displayPrices = getDisplayPrices(station);
                const cpoId = station.dcsTechnicalChargePointOperatorId;
                const cpoName = operators[cpoId] || 'Unbekannt';
                
                // Get pool details for address (pool ID is in 'id' field)
                const details = poolDetails[station.id] || {};
                const locationName = details.location_name || 'Ladestation';
                const street = details.street;
                const city = details.city;
                const zipCode = details.zip_code;
                const maxPower = details.max_power || 0;
                
                // Build address string
                let addressParts = [];
                if (street) addressParts.push(street);
                if (zipCode && city) {
                    addressParts.push(`${zipCode} ${city}`);
                } else if (city) {
                    addressParts.push(city);
                }
                const addressStr = addressParts.length > 0 
                    ? addressParts.join(', ')
                    : `${station.latitude.toFixed(5)}, ${station.longitude.toFixed(5)}`;
                
                // Build price badges for all available power types
                const priceBadges = displayPrices.map(p => {
                    const priceClass = getPriceClass(p.energy_price, p.currency || 'EUR');
                    return `<div class="station-price ${priceClass}" style="font-size: 0.8em; padding: 4px 10px;">${p.type}: ${formatPrice(p.energy_price, p.currency || 'EUR')}</div>`;
                }).join('');
                
                // Session fees info
                const sessionFees = displayPrices.filter(p => p.session_fee).map(p => 
                    `+${formatPrice(p.session_fee, p.currency || 'EUR')} ${p.type}`
                ).join(', ');
                
                // Blocking fees info
                const blockingFees = displayPrices.filter(p => p.blocking_fee).map(p => {
                    const info = formatBlockingFee(p);
                    return info ? `${p.type}: ${info}` : null;
                }).filter(Boolean);
                const blockingFeesHtml = blockingFees.length > 0 
                    ? `<span class="station-blocking-fee"><i class="fas fa-clock"></i> ${blockingFees.join(' / ')}</span>` 
                    : '';
                
                return `
                    <div class="station-card" data-lat="${station.latitude}" data-lng="${station.longitude}" data-station-id="${station.id}">
                        <div class="station-header">
                            <div class="station-info">
                                <div class="station-name">${locationName}</div>
                                <div class="station-cpo">${cpoName}</div>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: flex-end;">
                                ${priceBadges}
                            </div>
                        </div>
                        <div class="station-address">
                            <i class="fas fa-map-marker-alt"></i>
                            ${addressStr}
                        </div>
                        <div class="station-details">
                            <span><i class="fas fa-plug"></i> ${station.chargePointCount} Ladepunkte</span>
                            ${maxPower > 0 ? `<span><i class="fas fa-bolt"></i> ${maxPower} kW</span>` : ''}
                            ${sessionFees ? `<span><i class="fas fa-coins"></i> ${sessionFees}</span>` : ''}
                        </div>
                        ${blockingFeesHtml ? `<div class="station-details" style="padding-top: 6px; margin-top: 6px; border-top: 1px solid #1a3a5c;">${blockingFeesHtml}</div>` : ''}
                    </div>
                `;
            }).join('');
            
            // Add click handlers
            container.querySelectorAll('.station-card').forEach(card => {
                card.addEventListener('click', () => {
                    const lat = parseFloat(card.dataset.lat);
                    const lng = parseFloat(card.dataset.lng);
                    const stationId = card.dataset.stationId;
                    
                    map.setView([lat, lng], 17);
                    
                    // Open the popup for this station
                    if (stationId && markerMap[stationId]) {
                        markerMap[stationId].openPopup();
                    }
                    
                    // Highlight card
                    container.querySelectorAll('.station-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                });
            });
        }
        
        // Update stats
        function updateStats() {
            const stationsWithPrice = stations.filter(stationPassesFilters);
            
            document.getElementById('stationCount').textContent = stationsWithPrice.length;
            
            // Collect all EUR prices from all power types
            const allEurPrices = [];
            for (const s of stationsWithPrice) {
                const displayPrices = getDisplayPrices(s);
                for (const p of displayPrices) {
                    if ((p.currency || 'EUR') === 'EUR') {
                        allEurPrices.push(p.energy_price);
                    }
                }
            }
            
            if (allEurPrices.length > 0) {
                const avg = allEurPrices.reduce((a, b) => a + b, 0) / allEurPrices.length;
                const min = Math.min(...allEurPrices);
                
                document.getElementById('avgPrice').textContent = formatPrice(avg);
                document.getElementById('minPrice').textContent = formatPrice(min);
            } else {
                document.getElementById('avgPrice').textContent = '-';
                document.getElementById('minPrice').textContent = '-';
            }
        }
        
        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            
            // Tariff toggle
            document.querySelectorAll('.tariff-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    document.querySelectorAll('.tariff-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTariff = btn.dataset.tariff;
                    
                    // Don't reload from API - just use cached prices
                    // Apply cached prices to stations for new tariff
                    const powerTypes = getEffectivePowerTypes();
                    let cachedCount = 0;
                    let missingCount = 0;
                    
                    for (const station of stations) {
                        station.prices = {};
                        if (station.chargePoints && station.chargePoints.length > 0) {
                            const cpId = station.chargePoints[0].id;
                            for (const powerType of powerTypes) {
                                const cacheKey = `${cpId}_${currentTariff}_${powerType}_${currentMarket}`;
                                if (priceCache[cacheKey]) {
                                    station.prices[powerType] = priceCache[cacheKey];
                                    cachedCount++;
                                } else {
                                    missingCount++;
                                }
                            }
                        }
                    }
                    
                    console.log(`Tariff switch: ${cachedCount} cached, ${missingCount} missing`);
                    
                    // Update display immediately with cached data
                    updateMarkers();
                    updateList();
                    updateStats();
                    
                    // Load any missing prices in background
                    if (missingCount > 0) {
                        loadPrices();
                    }
                });
            });
            
            // Power type toggle (multi-select)
            document.querySelectorAll('.power-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const powerType = btn.dataset.power;
                    
                    // Toggle the selection
                    if (btn.classList.contains('active')) {
                        btn.classList.remove('active');
                        selectedPowerTypes.delete(powerType);
                    } else {
                        btn.classList.add('active');
                        selectedPowerTypes.add(powerType);
                    }
                    
                    loadStations();
                });
            });
            
            // Max price slider
            const priceSlider = document.getElementById('maxPrice');
            const priceValue = document.getElementById('maxPriceValue');
            
            priceSlider.addEventListener('input', () => {
                maxPriceFilter = parseFloat(priceSlider.value);
                priceValue.textContent = formatPrice(maxPriceFilter);
            });
            
            priceSlider.addEventListener('change', () => {
                updateMarkers();
                updateList();
                updateStats();
            });
            
            // Min power slider
            const powerSlider = document.getElementById('minPower');
            const powerValue = document.getElementById('minPowerValue');
            
            powerSlider.addEventListener('input', () => {
                minChargePower = parseInt(powerSlider.value);
                if (minChargePower === 0) {
                    powerValue.textContent = 'Alle';
                } else {
                    powerValue.textContent = `≥ ${minChargePower} kW`;
                }
            });
            
            powerSlider.addEventListener('change', () => {
                updateMarkers();
                updateList();
                updateStats();
            });
            
            // Operator filter mode buttons
            document.getElementById('includeMode').addEventListener('click', () => {
                operatorFilterMode = 'include';
                document.getElementById('includeMode').classList.add('active-include');
                document.getElementById('excludeMode').classList.remove('active-exclude');
            });
            
            document.getElementById('excludeMode').addEventListener('click', () => {
                operatorFilterMode = 'exclude';
                document.getElementById('excludeMode').classList.add('active-exclude');
                document.getElementById('includeMode').classList.remove('active-include');
            });
            
            document.getElementById('clearOperators').addEventListener('click', () => {
                includedOperators.clear();
                excludedOperators.clear();
                operatorFilterMode = 'include';
                document.getElementById('includeMode').classList.add('active-include');
                document.getElementById('excludeMode').classList.remove('active-exclude');
                renderOperatorTags();
                updateMarkers();
                updateList();
                updateStats();
            });
            
            // Sort select
            document.getElementById('sortSelect').addEventListener('change', (e) => {
                currentSortMode = e.target.value;
                updateList();
            });
            
            // Filter chips (Verfügbar, 24h)
            document.querySelectorAll('.filter-chip[data-filter]').forEach(chip => {
                chip.addEventListener('click', () => {
                    chip.classList.toggle('active');
                    const filter = chip.dataset.filter;
                    if (filter) {
                        activeFilters[filter] = chip.classList.contains('active');
                    }
                    loadStations();
                });
            });
            
            // Search - removed country restriction for international support
            const searchInput = document.getElementById('searchInput');
            const searchBtn = document.getElementById('searchBtn');
            
            const doSearch = async () => {
                const query = searchInput.value.trim();
                if (!query) return;
                
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
                    const results = await response.json();
                    
                    if (results.length > 0) {
                        const result = results[0];
                        const lat = parseFloat(result.lat);
                        const lng = parseFloat(result.lon);
                        const displayName = result.display_name;
                        
                        map.setView([lat, lng], 14);
                        
                        // Add marker for searched address
                        addSearchMarker(lat, lng, displayName);
                    }
                } catch (error) {
                    console.error('Search error:', error);
                }
            };
            
            searchBtn.addEventListener('click', doSearch);
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') doSearch();
            });
            
            // Mobile Panel Toggle Functionality
            const sidebar = document.getElementById('sidebar');
            const filtersPanel = document.getElementById('filters-tab');
            const listPanel = document.getElementById('list-tab');
            const mobileFilterToggle = document.getElementById('mobileFilterToggle');
            const mobileFilterBtn = document.getElementById('mobileFilterBtn');
            const mobileListToggle = document.getElementById('mobileListToggle');
            const mobilePanelClose = document.getElementById('mobilePanelClose');
            const mobilePanelToggles = document.querySelector('.mobile-panel-toggles');
            
            function closeMobilePanel() {
                // Enable transition for animation
                sidebar.classList.add('mobile-transitioning');
                sidebar.classList.remove('mobile-visible');
                filtersPanel.classList.remove('mobile-active');
                listPanel.classList.remove('mobile-active');
                mobileFilterToggle.classList.remove('active');
                mobileListToggle.classList.remove('active');
                if (mobileFilterBtn) mobileFilterBtn.classList.remove('active');
                if (mobilePanelToggles) mobilePanelToggles.classList.remove('filter-active');
                // Re-enable map interactions and remove transitioning class after animation
                document.body.style.overflow = '';
                setTimeout(() => {
                    sidebar.classList.remove('mobile-transitioning');
                }, 400);
            }
            
            function openMobilePanel(panelType) {
                // If same panel is open, close it
                if (sidebar.classList.contains('mobile-visible')) {
                    if (panelType === 'filter' && filtersPanel.classList.contains('mobile-active')) {
                        closeMobilePanel();
                        return;
                    }
                    if (panelType === 'list' && listPanel.classList.contains('mobile-active')) {
                        closeMobilePanel();
                        return;
                    }
                }
                
                // Reset panel states
                filtersPanel.classList.remove('mobile-active');
                listPanel.classList.remove('mobile-active');
                mobileFilterToggle.classList.remove('active');
                mobileListToggle.classList.remove('active');
                if (mobileFilterBtn) mobileFilterBtn.classList.remove('active');
                if (mobilePanelToggles) mobilePanelToggles.classList.remove('filter-active');
                
                // Enable transition for animation
                sidebar.classList.add('mobile-transitioning');
                
                // Open the requested panel
                sidebar.classList.add('mobile-visible');
                
                if (panelType === 'filter') {
                    filtersPanel.classList.add('mobile-active');
                    mobileFilterToggle.classList.add('active');
                    if (mobileFilterBtn) mobileFilterBtn.classList.add('active');
                    if (mobilePanelToggles) mobilePanelToggles.classList.add('filter-active');
                } else if (panelType === 'list') {
                    listPanel.classList.add('mobile-active');
                    mobileListToggle.classList.add('active');
                }
                
                // Prevent body scroll when panel is open
                document.body.style.overflow = 'hidden';
                
                // Remove transitioning class after animation completes
                setTimeout(() => {
                    sidebar.classList.remove('mobile-transitioning');
                }, 400);
            }
            
            mobileFilterToggle.addEventListener('click', () => {
                openMobilePanel('filter');
            });
            
            // New mobile filter button (top right)
            if (mobileFilterBtn) {
                mobileFilterBtn.addEventListener('click', () => {
                    openMobilePanel('filter');
                });
            }
            
            mobileListToggle.addEventListener('click', () => {
                openMobilePanel('list');
            });
            
            mobilePanelClose.addEventListener('click', closeMobilePanel);
            
            // Close panel with escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && sidebar.classList.contains('mobile-visible')) {
                    closeMobilePanel();
                }
            });
            
            // Handle station card click to close panel on mobile
            const originalUpdateList = updateList;
            updateList = function() {
                originalUpdateList();
                // Add mobile close behavior to station cards
                if (window.innerWidth <= 768) {
                    document.querySelectorAll('.station-card').forEach(card => {
                        card.addEventListener('click', () => {
                            // Small delay to allow map navigation
                            setTimeout(closeMobilePanel, 100);
                        });
                    });
                }
            };
            
            // Desktop Sidebar Toggle Functionality
            const sidebarToggle = document.getElementById('sidebarToggle');
            let sidebarCollapsed = false;
            let userManuallyToggled = false;
            
            function collapseSidebar(animate = true) {
                if (animate) {
                    sidebar.classList.add('transitioning');
                }
                sidebar.classList.add('collapsed');
                sidebarToggle.classList.remove('sidebar-open');
                sidebarCollapsed = true;
                // Invalidate map size and remove transitioning class after transition
                setTimeout(() => {
                    if (map) map.invalidateSize();
                    sidebar.classList.remove('transitioning');
                }, 350);
            }
            
            function expandSidebar(animate = true) {
                if (animate) {
                    sidebar.classList.add('transitioning');
                }
                sidebar.classList.remove('collapsed');
                sidebarToggle.classList.add('sidebar-open');
                sidebarCollapsed = false;
                // Invalidate map size and remove transitioning class after transition
                setTimeout(() => {
                    if (map) map.invalidateSize();
                    sidebar.classList.remove('transitioning');
                }, 350);
            }
            
            function toggleSidebar() {
                userManuallyToggled = true;
                if (sidebarCollapsed) {
                    expandSidebar(true);
                } else {
                    collapseSidebar(true);
                }
            }
            
            sidebarToggle.addEventListener('click', toggleSidebar);
            
            // Auto-collapse/expand based on window width
            let resizeTimeout = null;
            let previousIsMobile = window.innerWidth <= 768;
            
            function handleSidebarAutoCollapse() {
                const width = window.innerWidth;
                const isMobile = width <= 768;
                const wasDesktopBefore = previousIsMobile === false;
                const justSwitchedToDesktop = previousIsMobile && !isMobile;
                
                // On mobile (768px or below), ensure sidebar is not in desktop-collapsed state
                // to prevent hybrid state bugs with mobile toggles
                if (isMobile) {
                    sidebar.classList.remove('collapsed');
                    sidebar.classList.remove('transitioning');
                    sidebar.classList.remove('mobile-visible');
                    sidebar.classList.remove('mobile-transitioning');
                    sidebarToggle.classList.add('sidebar-open');
                    sidebarCollapsed = false;
                } else {
                    // On desktop, remove mobile-specific classes
                    sidebar.classList.remove('mobile-visible');
                    sidebar.classList.remove('mobile-transitioning');
                    filtersPanel.classList.remove('mobile-active');
                    listPanel.classList.remove('mobile-active');
                    mobileFilterToggle.classList.remove('active');
                    mobileListToggle.classList.remove('active');
                    if (mobileFilterBtn) mobileFilterBtn.classList.remove('active');
                    document.body.style.overflow = '';
                    
                    // Immediately apply collapsed state when switching from mobile to desktop < 1200px
                    // to prevent brief flash of expanded sidebar
                    if (justSwitchedToDesktop && width < 1200) {
                        sidebar.classList.add('collapsed');
                        sidebarToggle.classList.remove('sidebar-open');
                        sidebarCollapsed = true;
                    }
                }
                
                // Update previous state
                previousIsMobile = isMobile;
                
                // If user manually toggled on desktop, respect their choice
                if (!isMobile && userManuallyToggled) {
                    return;
                }
                
                // Auto-collapse below 1200px, auto-expand above (desktop only)
                if (!isMobile) {
                    if (width < 1200 && !sidebarCollapsed) {
                        // Collapse without animation when auto-collapsing
                        collapseSidebar(false);
                    } else if (width >= 1200 && sidebarCollapsed && !userManuallyToggled) {
                        // Expand without animation when auto-expanding
                        expandSidebar(false);
                    }
                }
                
                // Invalidate map size
                if (map) {
                    setTimeout(() => map.invalidateSize(), 50);
                }
            }
            
            // Reset manual toggle flag when crossing the 1200px threshold significantly
            let lastWidth = window.innerWidth;
            window.addEventListener('resize', () => {
                const currentWidth = window.innerWidth;
                const wasMobile = lastWidth <= 768;
                const isMobile = currentWidth <= 768;
                
                // Reset manual toggle if user resizes significantly
                if ((lastWidth < 1200 && currentWidth >= 1200) || (lastWidth >= 1200 && currentWidth < 1200)) {
                    userManuallyToggled = false;
                }
                
                // When crossing mobile/desktop threshold, handle immediately (no debounce)
                // to prevent brief flash of wrong state
                if (wasMobile !== isMobile) {
                    lastWidth = currentWidth;
                    if (resizeTimeout) {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = null;
                    }
                    handleSidebarAutoCollapse();
                    return;
                }
                
                lastWidth = currentWidth;
                
                // Debounce resize handling to avoid multiple rapid calls
                if (resizeTimeout) {
                    clearTimeout(resizeTimeout);
                }
                resizeTimeout = setTimeout(handleSidebarAutoCollapse, 10);
            });
            
            // Initial auto-collapse check
            handleSidebarAutoCollapse();
        });
    </script>
</body>
</html>
